import * as SecureStore from 'expo-secure-store';
import ENV from '../config/environment';

export interface TokenData {
  token: string;
  refreshToken?: string;
  expiresAt: number;
  issuedAt: number;
}

class TokenService {
  private static readonly TOKEN_KEY = 'user_token';
  private static readonly REFRESH_TOKEN_KEY = 'refresh_token';
  private static readonly TOKEN_EXPIRY_KEY = 'token_expiry';

  // Store token securely
  static async storeToken(tokenData: TokenData): Promise<void> {
    try {
      await Promise.all([
        SecureStore.setItemAsync(this.TOKEN_KEY, tokenData.token),
        SecureStore.setItemAsync(this.TOKEN_EXPIRY_KEY, tokenData.expiresAt.toString()),
        tokenData.refreshToken && SecureStore.setItemAsync(this.REFRESH_TOKEN_KEY, tokenData.refreshToken),
      ]);
    } catch (error) {
      console.error('Failed to store token:', error);
      throw new Error('Failed to store authentication token');
    }
  }

  // Retrieve token
  static async getToken(): Promise<string | null> {
    try {
      const token = await SecureStore.getItemAsync(this.TOKEN_KEY);
      const expiryString = await SecureStore.getItemAsync(this.TOKEN_EXPIRY_KEY);
      
      if (!token || !expiryString) {
        return null;
      }

      const expiryTime = parseInt(expiryString, 10);
      const now = Date.now();
      
      // Check if token is expired (with 5 minute buffer)
      if (now >= expiryTime - 300000) {
        await this.clearToken();
        return null;
      }

      return token;
    } catch (error) {
      console.error('Failed to retrieve token:', error);
      return null;
    }
  }

  // Get refresh token
  static async getRefreshToken(): Promise<string | null> {
    try {
      return await SecureStore.getItemAsync(this.REFRESH_TOKEN_KEY);
    } catch (error) {
      console.error('Failed to retrieve refresh token:', error);
      return null;
    }
  }

  // Check if token exists and is valid
  static async hasValidToken(): Promise<boolean> {
    const token = await this.getToken();
    return token !== null;
  }

  // Clear all tokens
  static async clearToken(): Promise<void> {
    try {
      await Promise.all([
        SecureStore.deleteItemAsync(this.TOKEN_KEY),
        SecureStore.deleteItemAsync(this.REFRESH_TOKEN_KEY),
        SecureStore.deleteItemAsync(this.TOKEN_EXPIRY_KEY),
      ]);
    } catch (error) {
      console.error('Failed to clear tokens:', error);
    }
  }

  // Parse JWT token (without verification - for client-side info only)
  static parseJWTPayload(token: string): any {
    try {
      const base64Url = token.split('.')[1];
      const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
      const jsonPayload = decodeURIComponent(
        atob(base64)
          .split('')
          .map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
          .join('')
      );
      return JSON.parse(jsonPayload);
    } catch (error) {
      console.error('Failed to parse JWT:', error);
      return null;
    }
  }

  // Get token expiry time
  static async getTokenExpiry(): Promise<number | null> {
    try {
      const expiryString = await SecureStore.getItemAsync(this.TOKEN_EXPIRY_KEY);
      return expiryString ? parseInt(expiryString, 10) : null;
    } catch (error) {
      console.error('Failed to get token expiry:', error);
      return null;
    }
  }

  // Check if token will expire soon (within 5 minutes)
  static async isTokenExpiringSoon(): Promise<boolean> {
    const expiry = await this.getTokenExpiry();
    if (!expiry) return true;
    
    const now = Date.now();
    const fiveMinutes = 5 * 60 * 1000;
    return now >= expiry - fiveMinutes;
  }
}

export default TokenService;